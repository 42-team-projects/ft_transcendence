// solidity :

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TournamentScoreStorage {
    struct GameResult {
        string player1;
        uint score1;
        string player2;
        uint score2;
    }

    GameResult[] public gameResults;

    function storeGameResult(string memory player1, uint score1, string memory player2, uint score2) public {
        GameResult memory newResult = GameResult(player1, score1, player2, score2);
        gameResults.push(newResult);
    }

    function getGameResult(uint index) public view returns (string memory player1, uint score1, string memory player2, uint score2) {
        require(index < gameResults.length, "Index out of bounds");
        GameResult memory result = gameResults[index];
        return (result.player1, result.score1, result.player2, result.score2);
    }

    function getGameResultsCount() public view returns (uint) {
        return gameResults.length;
    }
}



// Python: 

from web3 import Web3
from django.conf import settings
from django.http import JsonResponse

# Connect to the Ethereum network
web3 = Web3(Web3.HTTPProvider(settings.ETHEREUM_PROVIDER_URL))

# Set up contract details
contract_address = settings.CONTRACT_ADDRESS
contract_abi = settings.CONTRACT_ABI
contract = web3.eth.contract(address=contract_address, abi=contract_abi)

def get_game_result(index):
    # Call the smart contract to retrieve game result
    result = contract.functions.getGameResult(index).call()
    return {
        'player1': result[0],
        'score1': result[1],
        'player2': result[2],
        'score2': result[3]
    }

def get_game_results_count():
    # Call the smart contract to get the number of game results
    count = contract.functions.getGameResultsCount().call()
    return count

def launch_tournament_test(request):
    try:
        tournament = Tournament.objects.get(id=2)
        print("Tournament with name {} is started.".format(tournament.tournament_name))
        
        while tournament.players.count() > 1:
            players = list(tournament.players.all())  # Convert QuerySet to list
            i = 0
            while i < len(players) - 1:
                player1 = players[i]
                player2 = players[i + 1]
                score1, score2 = play_game(player1, player2)
                
                # Store game result in blockchain
                receipt = store_game_result(player1.name, score1, player2.name, score2)
                print(f"Game result stored in blockchain. Transaction receipt: {receipt}")

                # Determine the winner based on scores
                if score1 >= score2:
                    tournament.players.remove(player2)
                else:
                    tournament.players.remove(player1)
                i += 2

        if tournament.players.count() == 1:
            winner = tournament.players.first()
            return JsonResponse({"Player Win": winner.name}, safe=False)
        else:
            return JsonResponse({"error": "No winner found"}, status=404)
    
    except Tournament.DoesNotExist:
        return JsonResponse({'error': 'Tournament not found'}, status=404)

def retrieve_tournament_scores(request):
    try:
        count = get_game_results_count()
        results = []
        for i in range(count):
            result = get_game_result(i)
            results.append(result)
        return JsonResponse({"scores": results}, safe=False)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
